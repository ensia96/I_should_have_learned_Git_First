continue : 명령을 조기종료하고, 다시 순환명령을 실행

break : 명령을 조기종료하고, 그 시점의 결과값을 함수호출인자에 할당

return : 결과값을 함수호출인자에 할당

nesting : 중첩

파이썬의 while 문은 else 문 가능
While 문의 else 문도 while의 조건문이 False 이면 실행
즉 기본적인 명령이 담긴 while 문이 종료되면 else 문이 실행된다는 뜻입니다.

Dictionary는 values, item 라는 함수를 속성으로 가지고있다.
dictionary의 value 들을 리턴
dictionary의 item ( key, value ) 들을 튜플로 리턴

가장 작은 단위로 맵핑되어있는 자료형 : key value pair

딕셔너리 단위로 원소를 갖는 배열이 있을 수 있다.

nested dictionary
딕셔너리를 임의의 변수의 value 로 맵핑시켜, key value pair 의 형태로 만든 뒤 저장하는 딕셔너리로 만들 수도 있다.


간단판별명령

try :
	에러를 일으킬 것 같은 명령
except ' 발생가능한 에러종류 ' :
	핸들러
else :
	다른 동작

try 에 동작여부를 판별하고싶은 명령 ( 에러를 일으킬 것 같은 명령 ) 을 입력,
예상한 에러의 종류를 except 에 지정하여, 출력되지 않도록 ( 예외처리 ) 를 한 뒤, 핸들러를 동작 시킴
핸들러는 원하는 방식의 에러문구를 지정하거나, else 부에 지정할 다른 동작으로 이동을 유도

except 구문에서 as 를 이용해 좌항에 exception 을 적고, 그 exceiption 에 에러값을 담아 우항에 입력한 값에 할당할 수 있다.


decorator : @ 함수이름 -> 어떤 함수 위에 넣으면, decorator 함수를 우선호출

	함수는 함수의 내부에서도 선언될 수 있다.

	( 반복, 조건문의 중첩과 비슷한 느낌의 로직으로도 구현 가능 )

	decorator 함수라는 큰 객체가

	자신 내부의 변수, 함수 정의 등의 선언에 대해

	외부 객체들에 영향을 주지 않도록

	폐쇄적인 구조를 만들어 주는 역할을 함. ( 울타리같은 느낌 )

	함수공장! 이라고도 부를만 한 이유가 있음.

	위와 같은 특징 덕분에 decorator 는,

	원하는 조건에 맞춰 여러 함수를 가공하거나,
	함수의 접근권한 등을 판별하는 기능으로 동작시키는 것이 가능하다.


함수() 에서
함수 만을 호출하면 함수의 원형객체가 호출된다.

__함수__ : special method / js 에선 protolink

__init__ : 초기화함수 ( 이니셜을 잡아줌 )

self : 항상 parameter 로 지정되어 있어야 하고, 첫 parameter 여야한다

	js 에서 this 랑 비슷

method 와 attribute
모든 메소드에는 self 파라미터가 첫번째 파라미터로 들어가야 합니다.
객체에서 메소드를 사용할때는 dot(.) 을 사용하여 객체를 호출

<객체>.<메소드>

이를 dot notation 이라고 합니다

class : 그룹과 비슷 / 구성요소들이 가진 공통의 특징을 묶어둔 것 / 실체 X

	class 키워드로 정의할 수 있음
		앞글자를 대문자로 사용해야함


object : class 안에 구현된 실체에 대한 개념

instance : class 가 호출되어 object 라는 개념을 통해 실체화된 요소


https://docs.python.org/ko/3/tutorial/classes.html

클래스에 대해 보편적으로 받아들여지는 용어들이 없는 상태에서, 이따금 스몰토크나 C++ 용어들을 사용할 것입니다. C++ 보다 객체 지향적 개념들이 파이썬의 것과 더 가까우므로 모듈라-3 용어를 사용할 수도 있지만, 들어본 독자들이 별로 없을 것으로 예상합니다.

import 로 모듈참조를 할 수 있다.

from <모듈 이름> import <함수/변수/클래스1>, <함수/변수/클래스2>, ..., <함수/변수/클래스N> 흑은 <*>


예를 들어, my_module 모듈에서 my_module_func 함수와 my_module_var 변수를 import 하고자 한다면 다음처럼 할 수 있습니다.

from my_module import my_module_func, my_module_var

print(my_module_var)
my_module_func()

모듈 이름을 붙이지 않고 곧바로 원하는 함수나 변수 그리고 클래스를 호출할 수 있습니다

편리하겠지만, local scope를 가지고 있는 다른 변수/함수/클래스 들과 이름 충돌이 날 수 있는데, 만일 이름 충돌이 일어났을 경우 알기가 쉽지 않을수있음

import as 키워드를 사용해서 새로운 이름을 주어서 사용할 수 있습니다.

from import as 구문으로 함수충돌을 막거나, import as 구문으로 모듈이름을 간략화할 수 있음

모듈에 여러 함수들을 담았던 것처럼, 패키지에도 여러 모듈들을 담을 수 있다.

패키지도 import 구문으로 참조시켜줘야 내부 모듈들에 접근할 수 있다.

package 가 import 될 때, class 에서 그랬듯 이니셜을 잡아줘야할 때가 있는데,

__init__.py 파일로 모듈을 만들어 초기값으로 지정하도록 할 수 있다.

__init__.py 이 할 수 있는 역할

Import 할때 경로의 총 길이 줄여주기
Package 에서 import 할 수 있는 변수/함수/클래스 제한하기
그 외 package 가 import 될 때 꼭 먼저 실행되어야 하는 코드들 설정하기

모듈의 모든 함수가 다 외부로 노출될 수 있는건 아닐수 있습니다.
내부적으로만 사용되어야 하는 함수
package 외부에서 import되어 사용되는 것을 막기 위해서는 __all__ 변수를 지정

package를 통해 import 될 수 있는 요소들은 모두 __all__ 변수를 통해 정의됨
그리고 __all__ 변수의 default 값은 모든 함수/변수/클래스 입니다. 
그러므로 __all__ 변수를 따로 정의해줌으로 import 될 수 있는 요소들을 제한할 수 있는 것입니다.
__all__ 변수는 string 값의 요소를 가지고 있는 list 입니다 (list of strings). 
그러므로 import 되길 원하는 요소들을 string으로 list에 선언해주면 됩니다.

python 에게 import 를 시키면 어디서 찾아올까?

import 뒤의 적힌 파일이나 디렉토리의 이름을 찾는데

sys.modules -> built-in modules -> sys.path

sys.modules
단순한 dictionary 입니다. 그리고 이미 import된 모듈과 package들을 저장하고 있습니다.
즉, 한번 import된 모듈과 package들은 파이썬이 또 다시 찾지 않아도 되도록 하는 기능을 가지고 있습니다.
그러므로 새로 import 하는 모듈은 sys.modules 에서 찾을 수 없습니다.

built-in modules
파이썬에서 제공하는 파이썬 공식 라이브러리들 입니다. 
Built-in 모듈들은 이미 파이썬에 포함되어 나오므로 파이썬이 쉽게 찾을 수 있습니다.

sys.path
마지막으로 보는 장소가 바로 sys.path 입니다. 
sys.path는 기본적으로 list이며 string 요소들을 가지고 있는 list 입니다.
각 string 요소들은 다음 처럼 경로를 나타냅니다: